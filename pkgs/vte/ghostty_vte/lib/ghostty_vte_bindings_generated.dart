// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// Create a new OSC parser instance.
///
/// Creates a new OSC (Operating System Command) parser using the provided
/// allocator. The parser must be freed using ghostty_vt_osc_free() when
/// no longer needed.
///
/// @param allocator Pointer to the allocator to use for memory management, or NULL to use the default allocator
/// @param parser Pointer to store the created parser handle
/// @return GHOSTTY_SUCCESS on success, or an error code on failure
///
/// @ingroup osc
@ffi.Native<
  ffi.Int Function(ffi.Pointer<GhosttyAllocator>, ffi.Pointer<GhosttyOscParser>)
>(symbol: 'ghostty_osc_new')
external int _ghostty_osc_new(
  ffi.Pointer<GhosttyAllocator> allocator,
  ffi.Pointer<GhosttyOscParser> parser,
);

GhosttyResult ghostty_osc_new(
  ffi.Pointer<GhosttyAllocator> allocator,
  ffi.Pointer<GhosttyOscParser> parser,
) => GhosttyResult.fromValue(_ghostty_osc_new(allocator, parser));

/// Free an OSC parser instance.
///
/// Releases all resources associated with the OSC parser. After this call,
/// the parser handle becomes invalid and must not be used.
///
/// @param parser The parser handle to free (may be NULL)
///
/// @ingroup osc
@ffi.Native<ffi.Void Function(GhosttyOscParser)>()
external void ghostty_osc_free(GhosttyOscParser parser);

/// Reset an OSC parser instance to its initial state.
///
/// Resets the parser state, clearing any partially parsed OSC sequences
/// and returning the parser to its initial state. This is useful for
/// reusing a parser instance or recovering from parse errors.
///
/// @param parser The parser handle to reset, must not be null.
///
/// @ingroup osc
@ffi.Native<ffi.Void Function(GhosttyOscParser)>()
external void ghostty_osc_reset(GhosttyOscParser parser);

/// Parse the next byte in an OSC sequence.
///
/// Processes a single byte as part of an OSC sequence. The parser maintains
/// internal state to track the progress through the sequence. Call this
/// function for each byte in the sequence data.
///
/// When finished pumping the parser with bytes, call ghostty_osc_end
/// to get the final result.
///
/// @param parser The parser handle, must not be null.
/// @param byte The next byte to parse
///
/// @ingroup osc
@ffi.Native<ffi.Void Function(GhosttyOscParser, ffi.Uint8)>()
external void ghostty_osc_next(GhosttyOscParser parser, int byte);

/// Finalize OSC parsing and retrieve the parsed command.
///
/// Call this function after feeding all bytes of an OSC sequence to the parser
/// using ghostty_osc_next() with the exception of the terminating character
/// (ESC or ST). This function finalizes the parsing process and returns the
/// parsed OSC command.
///
/// The return value is never NULL. Invalid commands will return a command
/// with type GHOSTTY_OSC_COMMAND_INVALID.
///
/// The terminator parameter specifies the byte that terminated the OSC sequence
/// (typically 0x07 for BEL or 0x5C for ST after ESC). This information is
/// preserved in the parsed command so that responses can use the same terminator
/// format for better compatibility with the calling program. For commands that
/// do not require a response, this parameter is ignored and the resulting
/// command will not retain the terminator information.
///
/// The returned command handle is valid until the next call to any
/// `ghostty_osc_*` function with the same parser instance with the exception
/// of command introspection functions such as `ghostty_osc_command_type`.
///
/// @param parser The parser handle, must not be null.
/// @param terminator The terminating byte of the OSC sequence (0x07 for BEL, 0x5C for ST)
/// @return Handle to the parsed OSC command
///
/// @ingroup osc
@ffi.Native<GhosttyOscCommand Function(GhosttyOscParser, ffi.Uint8)>()
external GhosttyOscCommand ghostty_osc_end(
  GhosttyOscParser parser,
  int terminator,
);

/// Get the type of an OSC command.
///
/// Returns the type identifier for the given OSC command. This can be used
/// to determine what kind of command was parsed and what data might be
/// available from it.
///
/// @param command The OSC command handle to query (may be NULL)
/// @return The command type, or GHOSTTY_OSC_COMMAND_INVALID if command is NULL
///
/// @ingroup osc
@ffi.Native<ffi.UnsignedInt Function(GhosttyOscCommand)>(
  symbol: 'ghostty_osc_command_type',
)
external int _ghostty_osc_command_type(GhosttyOscCommand command);

GhosttyOscCommandType ghostty_osc_command_type(GhosttyOscCommand command) =>
    GhosttyOscCommandType.fromValue(_ghostty_osc_command_type(command));

/// Extract data from an OSC command.
///
/// Extracts typed data from the given OSC command based on the specified
/// data type. The output pointer must be of the appropriate type for the
/// requested data kind. Valid command types, output types, and memory
/// safety information are documented in the `GhosttyOscCommandData` enum.
///
/// @param command The OSC command handle to query (may be NULL)
/// @param data The type of data to extract
/// @param out Pointer to store the extracted data (type depends on data parameter)
/// @return true if data extraction was successful, false otherwise
///
/// @ingroup osc
@ffi.Native<
  ffi.Bool Function(GhosttyOscCommand, ffi.UnsignedInt, ffi.Pointer<ffi.Void>)
>(symbol: 'ghostty_osc_command_data')
external bool _ghostty_osc_command_data(
  GhosttyOscCommand command,
  int data,
  ffi.Pointer<ffi.Void> out,
);

bool ghostty_osc_command_data(
  GhosttyOscCommand command,
  GhosttyOscCommandData data,
  ffi.Pointer<ffi.Void> out,
) => _ghostty_osc_command_data(command, data.value, out);

/// Get the RGB color components.
///
/// This function extracts the individual red, green, and blue components
/// from a GhosttyColorRgb value. Primarily useful in WebAssembly environments
/// where accessing struct fields directly is difficult.
///
/// @param color The RGB color value
/// @param r Pointer to store the red component (0-255)
/// @param g Pointer to store the green component (0-255)
/// @param b Pointer to store the blue component (0-255)
///
/// @ingroup sgr
@ffi.Native<
  ffi.Void Function(
    GhosttyColorRgb,
    ffi.Pointer<ffi.Uint8>,
    ffi.Pointer<ffi.Uint8>,
    ffi.Pointer<ffi.Uint8>,
  )
>()
external void ghostty_color_rgb_get(
  GhosttyColorRgb color,
  ffi.Pointer<ffi.Uint8> r,
  ffi.Pointer<ffi.Uint8> g,
  ffi.Pointer<ffi.Uint8> b,
);

/// Create a new SGR parser instance.
///
/// Creates a new SGR (Select Graphic Rendition) parser using the provided
/// allocator. The parser must be freed using ghostty_sgr_free() when
/// no longer needed.
///
/// @param allocator Pointer to the allocator to use for memory management, or
/// NULL to use the default allocator
/// @param parser Pointer to store the created parser handle
/// @return GHOSTTY_SUCCESS on success, or an error code on failure
///
/// @ingroup sgr
@ffi.Native<
  ffi.Int Function(ffi.Pointer<GhosttyAllocator>, ffi.Pointer<GhosttySgrParser>)
>(symbol: 'ghostty_sgr_new')
external int _ghostty_sgr_new(
  ffi.Pointer<GhosttyAllocator> allocator,
  ffi.Pointer<GhosttySgrParser> parser,
);

GhosttyResult ghostty_sgr_new(
  ffi.Pointer<GhosttyAllocator> allocator,
  ffi.Pointer<GhosttySgrParser> parser,
) => GhosttyResult.fromValue(_ghostty_sgr_new(allocator, parser));

/// Free an SGR parser instance.
///
/// Releases all resources associated with the SGR parser. After this call,
/// the parser handle becomes invalid and must not be used. This includes
/// any attributes previously returned by ghostty_sgr_next().
///
/// @param parser The parser handle to free (may be NULL)
///
/// @ingroup sgr
@ffi.Native<ffi.Void Function(GhosttySgrParser)>()
external void ghostty_sgr_free(GhosttySgrParser parser);

/// Reset an SGR parser instance to the beginning of the parameter list.
///
/// Resets the parser's iteration state without clearing the parameters.
/// After calling this, ghostty_sgr_next() will start from the beginning
/// of the parameter list again.
///
/// @param parser The parser handle to reset, must not be NULL
///
/// @ingroup sgr
@ffi.Native<ffi.Void Function(GhosttySgrParser)>()
external void ghostty_sgr_reset(GhosttySgrParser parser);

/// Set SGR parameters for parsing.
///
/// Sets the SGR parameter list to parse. Parameters are the numeric values
/// from a CSI SGR sequence (e.g., for `ESC[1;31m`, params would be {1, 31}).
///
/// The separators array optionally specifies the separator type for each
/// parameter position. Each byte should be either ';' for semicolon or ':'
/// for colon. This is needed for certain color formats that use colon
/// separators (e.g., `ESC[4:3m` for curly underline). Any invalid separator
/// values are treated as semicolons. The separators array must have the same
/// length as the params array, if it is not NULL.
///
/// If separators is NULL, all parameters are assumed to be semicolon-separated.
///
/// This function makes an internal copy of the parameter and separator data,
/// so the caller can safely free or modify the input arrays after this call.
///
/// After calling this function, the parser is automatically reset and ready
/// to iterate from the beginning.
///
/// @param parser The parser handle, must not be NULL
/// @param params Array of SGR parameter values
/// @param separators Optional array of separator characters (';' or ':'), or
/// NULL
/// @param len Number of parameters (and separators if provided)
/// @return GHOSTTY_SUCCESS on success, or an error code on failure
///
/// @ingroup sgr
@ffi.Native<
  ffi.Int Function(
    GhosttySgrParser,
    ffi.Pointer<ffi.Uint16>,
    ffi.Pointer<ffi.Char>,
    ffi.Size,
  )
>(symbol: 'ghostty_sgr_set_params')
external int _ghostty_sgr_set_params(
  GhosttySgrParser parser,
  ffi.Pointer<ffi.Uint16> params,
  ffi.Pointer<ffi.Char> separators,
  int len,
);

GhosttyResult ghostty_sgr_set_params(
  GhosttySgrParser parser,
  ffi.Pointer<ffi.Uint16> params,
  ffi.Pointer<ffi.Char> separators,
  int len,
) => GhosttyResult.fromValue(
  _ghostty_sgr_set_params(parser, params, separators, len),
);

/// Get the next SGR attribute.
///
/// Parses and returns the next attribute from the parameter list.
/// Call this function repeatedly until it returns false to process
/// all attributes in the sequence.
///
/// @param parser The parser handle, must not be NULL
/// @param attr Pointer to store the next attribute
/// @return true if an attribute was returned, false if no more attributes
///
/// @ingroup sgr
@ffi.Native<
  ffi.Bool Function(GhosttySgrParser, ffi.Pointer<GhosttySgrAttribute>)
>()
external bool ghostty_sgr_next(
  GhosttySgrParser parser,
  ffi.Pointer<GhosttySgrAttribute> attr,
);

/// Get the full parameter list from an unknown SGR attribute.
///
/// This function retrieves the full parameter list that was provided to the
/// parser when an unknown attribute was encountered. Primarily useful in
/// WebAssembly environments where accessing struct fields directly is difficult.
///
/// @param unknown The unknown attribute data
/// @param ptr Pointer to store the pointer to the parameter array (may be NULL)
/// @return The length of the full parameter array
///
/// @ingroup sgr
@ffi.Native<
  ffi.Size Function(GhosttySgrUnknown, ffi.Pointer<ffi.Pointer<ffi.Uint16>>)
>()
external int ghostty_sgr_unknown_full(
  GhosttySgrUnknown unknown,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> ptr,
);

/// Get the partial parameter list from an unknown SGR attribute.
///
/// This function retrieves the partial parameter list where parsing stopped
/// when an unknown attribute was encountered. Primarily useful in WebAssembly
/// environments where accessing struct fields directly is difficult.
///
/// @param unknown The unknown attribute data
/// @param ptr Pointer to store the pointer to the parameter array (may be NULL)
/// @return The length of the partial parameter array
///
/// @ingroup sgr
@ffi.Native<
  ffi.Size Function(GhosttySgrUnknown, ffi.Pointer<ffi.Pointer<ffi.Uint16>>)
>()
external int ghostty_sgr_unknown_partial(
  GhosttySgrUnknown unknown,
  ffi.Pointer<ffi.Pointer<ffi.Uint16>> ptr,
);

/// Get the tag from an SGR attribute.
///
/// This function extracts the tag that identifies which type of attribute
/// this is. Primarily useful in WebAssembly environments where accessing
/// struct fields directly is difficult.
///
/// @param attr The SGR attribute
/// @return The attribute tag
///
/// @ingroup sgr
@ffi.Native<ffi.UnsignedInt Function(GhosttySgrAttribute)>(
  symbol: 'ghostty_sgr_attribute_tag',
)
external int _ghostty_sgr_attribute_tag(GhosttySgrAttribute attr);

GhosttySgrAttributeTag ghostty_sgr_attribute_tag(GhosttySgrAttribute attr) =>
    GhosttySgrAttributeTag.fromValue(_ghostty_sgr_attribute_tag(attr));

/// Get the value from an SGR attribute.
///
/// This function returns a pointer to the value union from an SGR attribute. Use
/// the tag to determine which field of the union is valid. Primarily useful in
/// WebAssembly environments where accessing struct fields directly is difficult.
///
/// @param attr Pointer to the SGR attribute
/// @return Pointer to the attribute value union
///
/// @ingroup sgr
@ffi.Native<
  ffi.Pointer<GhosttySgrAttributeValue> Function(
    ffi.Pointer<GhosttySgrAttribute>,
  )
>()
external ffi.Pointer<GhosttySgrAttributeValue> ghostty_sgr_attribute_value(
  ffi.Pointer<GhosttySgrAttribute> attr,
);

/// Create a new key event instance.
///
/// Creates a new key event with default values. The event must be freed using
/// ghostty_key_event_free() when no longer needed.
///
/// @param allocator Pointer to the allocator to use for memory management, or NULL to use the default allocator
/// @param event Pointer to store the created key event handle
/// @return GHOSTTY_SUCCESS on success, or an error code on failure
///
/// @ingroup key
@ffi.Native<
  ffi.Int Function(ffi.Pointer<GhosttyAllocator>, ffi.Pointer<GhosttyKeyEvent>)
>(symbol: 'ghostty_key_event_new')
external int _ghostty_key_event_new(
  ffi.Pointer<GhosttyAllocator> allocator,
  ffi.Pointer<GhosttyKeyEvent> event,
);

GhosttyResult ghostty_key_event_new(
  ffi.Pointer<GhosttyAllocator> allocator,
  ffi.Pointer<GhosttyKeyEvent> event,
) => GhosttyResult.fromValue(_ghostty_key_event_new(allocator, event));

/// Free a key event instance.
///
/// Releases all resources associated with the key event. After this call,
/// the event handle becomes invalid and must not be used.
///
/// @param event The key event handle to free (may be NULL)
///
/// @ingroup key
@ffi.Native<ffi.Void Function(GhosttyKeyEvent)>()
external void ghostty_key_event_free(GhosttyKeyEvent event);

/// Set the key action (press, release, repeat).
///
/// @param event The key event handle, must not be NULL
/// @param action The action to set
///
/// @ingroup key
@ffi.Native<ffi.Void Function(GhosttyKeyEvent, ffi.UnsignedInt)>(
  symbol: 'ghostty_key_event_set_action',
)
external void _ghostty_key_event_set_action(GhosttyKeyEvent event, int action);

void ghostty_key_event_set_action(
  GhosttyKeyEvent event,
  GhosttyKeyAction action,
) => _ghostty_key_event_set_action(event, action.value);

/// Get the key action (press, release, repeat).
///
/// @param event The key event handle, must not be NULL
/// @return The key action
///
/// @ingroup key
@ffi.Native<ffi.UnsignedInt Function(GhosttyKeyEvent)>(
  symbol: 'ghostty_key_event_get_action',
)
external int _ghostty_key_event_get_action(GhosttyKeyEvent event);

GhosttyKeyAction ghostty_key_event_get_action(GhosttyKeyEvent event) =>
    GhosttyKeyAction.fromValue(_ghostty_key_event_get_action(event));

/// Set the physical key code.
///
/// @param event The key event handle, must not be NULL
/// @param key The physical key code to set
///
/// @ingroup key
@ffi.Native<ffi.Void Function(GhosttyKeyEvent, ffi.UnsignedInt)>(
  symbol: 'ghostty_key_event_set_key',
)
external void _ghostty_key_event_set_key(GhosttyKeyEvent event, int key);

void ghostty_key_event_set_key(GhosttyKeyEvent event, GhosttyKey key) =>
    _ghostty_key_event_set_key(event, key.value);

/// Get the physical key code.
///
/// @param event The key event handle, must not be NULL
/// @return The physical key code
///
/// @ingroup key
@ffi.Native<ffi.UnsignedInt Function(GhosttyKeyEvent)>(
  symbol: 'ghostty_key_event_get_key',
)
external int _ghostty_key_event_get_key(GhosttyKeyEvent event);

GhosttyKey ghostty_key_event_get_key(GhosttyKeyEvent event) =>
    GhosttyKey.fromValue(_ghostty_key_event_get_key(event));

/// Set the modifier keys bitmask.
///
/// @param event The key event handle, must not be NULL
/// @param mods The modifier keys bitmask to set
///
/// @ingroup key
@ffi.Native<ffi.Void Function(GhosttyKeyEvent, GhosttyMods)>()
external void ghostty_key_event_set_mods(GhosttyKeyEvent event, int mods);

/// Get the modifier keys bitmask.
///
/// @param event The key event handle, must not be NULL
/// @return The modifier keys bitmask
///
/// @ingroup key
@ffi.Native<GhosttyMods Function(GhosttyKeyEvent)>()
external int ghostty_key_event_get_mods(GhosttyKeyEvent event);

/// Set the consumed modifiers bitmask.
///
/// @param event The key event handle, must not be NULL
/// @param consumed_mods The consumed modifiers bitmask to set
///
/// @ingroup key
@ffi.Native<ffi.Void Function(GhosttyKeyEvent, GhosttyMods)>()
external void ghostty_key_event_set_consumed_mods(
  GhosttyKeyEvent event,
  int consumed_mods,
);

/// Get the consumed modifiers bitmask.
///
/// @param event The key event handle, must not be NULL
/// @return The consumed modifiers bitmask
///
/// @ingroup key
@ffi.Native<GhosttyMods Function(GhosttyKeyEvent)>()
external int ghostty_key_event_get_consumed_mods(GhosttyKeyEvent event);

/// Set whether the key event is part of a composition sequence.
///
/// @param event The key event handle, must not be NULL
/// @param composing Whether the key event is part of a composition sequence
///
/// @ingroup key
@ffi.Native<ffi.Void Function(GhosttyKeyEvent, ffi.Bool)>()
external void ghostty_key_event_set_composing(
  GhosttyKeyEvent event,
  bool composing,
);

/// Get whether the key event is part of a composition sequence.
///
/// @param event The key event handle, must not be NULL
/// @return Whether the key event is part of a composition sequence
///
/// @ingroup key
@ffi.Native<ffi.Bool Function(GhosttyKeyEvent)>()
external bool ghostty_key_event_get_composing(GhosttyKeyEvent event);

/// Set the UTF-8 text generated by the key event.
///
/// The key event does NOT take ownership of the text pointer. The caller
/// must ensure the string remains valid for the lifetime needed by the event.
///
/// @param event The key event handle, must not be NULL
/// @param utf8 The UTF-8 text to set (or NULL for empty)
/// @param len Length of the UTF-8 text in bytes
///
/// @ingroup key
@ffi.Native<
  ffi.Void Function(GhosttyKeyEvent, ffi.Pointer<ffi.Char>, ffi.Size)
>()
external void ghostty_key_event_set_utf8(
  GhosttyKeyEvent event,
  ffi.Pointer<ffi.Char> utf8,
  int len,
);

/// Get the UTF-8 text generated by the key event.
///
/// The returned pointer is valid until the event is freed or the UTF-8 text is modified.
///
/// @param event The key event handle, must not be NULL
/// @param len Pointer to store the length of the UTF-8 text in bytes (may be NULL)
/// @return The UTF-8 text (or NULL for empty)
///
/// @ingroup key
@ffi.Native<
  ffi.Pointer<ffi.Char> Function(GhosttyKeyEvent, ffi.Pointer<ffi.Size>)
>()
external ffi.Pointer<ffi.Char> ghostty_key_event_get_utf8(
  GhosttyKeyEvent event,
  ffi.Pointer<ffi.Size> len,
);

/// Set the unshifted Unicode codepoint.
///
/// @param event The key event handle, must not be NULL
/// @param codepoint The unshifted Unicode codepoint to set
///
/// @ingroup key
@ffi.Native<ffi.Void Function(GhosttyKeyEvent, ffi.Uint32)>()
external void ghostty_key_event_set_unshifted_codepoint(
  GhosttyKeyEvent event,
  int codepoint,
);

/// Get the unshifted Unicode codepoint.
///
/// @param event The key event handle, must not be NULL
/// @return The unshifted Unicode codepoint
///
/// @ingroup key
@ffi.Native<ffi.Uint32 Function(GhosttyKeyEvent)>()
external int ghostty_key_event_get_unshifted_codepoint(GhosttyKeyEvent event);

/// Create a new key encoder instance.
///
/// Creates a new key encoder with default options. The encoder can be configured
/// using ghostty_key_encoder_setopt() and must be freed using
/// ghostty_key_encoder_free() when no longer needed.
///
/// @param allocator Pointer to the allocator to use for memory management, or NULL to use the default allocator
/// @param encoder Pointer to store the created encoder handle
/// @return GHOSTTY_SUCCESS on success, or an error code on failure
///
/// @ingroup key
@ffi.Native<
  ffi.Int Function(
    ffi.Pointer<GhosttyAllocator>,
    ffi.Pointer<GhosttyKeyEncoder>,
  )
>(symbol: 'ghostty_key_encoder_new')
external int _ghostty_key_encoder_new(
  ffi.Pointer<GhosttyAllocator> allocator,
  ffi.Pointer<GhosttyKeyEncoder> encoder,
);

GhosttyResult ghostty_key_encoder_new(
  ffi.Pointer<GhosttyAllocator> allocator,
  ffi.Pointer<GhosttyKeyEncoder> encoder,
) => GhosttyResult.fromValue(_ghostty_key_encoder_new(allocator, encoder));

/// Free a key encoder instance.
///
/// Releases all resources associated with the key encoder. After this call,
/// the encoder handle becomes invalid and must not be used.
///
/// @param encoder The encoder handle to free (may be NULL)
///
/// @ingroup key
@ffi.Native<ffi.Void Function(GhosttyKeyEncoder)>()
external void ghostty_key_encoder_free(GhosttyKeyEncoder encoder);

/// Set an option on the key encoder.
///
/// Configures the behavior of the key encoder. Options control various aspects
/// of encoding such as terminal modes (cursor key application mode, keypad mode),
/// protocol selection (Kitty keyboard protocol flags), and platform-specific
/// behaviors (macOS option-as-alt).
///
/// A null pointer value does nothing. It does not reset the value to the
/// default. The setopt call will do nothing.
///
/// @param encoder The encoder handle, must not be NULL
/// @param option The option to set
/// @param value Pointer to the value to set (type depends on the option)
///
/// @ingroup key
@ffi.Native<
  ffi.Void Function(GhosttyKeyEncoder, ffi.UnsignedInt, ffi.Pointer<ffi.Void>)
>(symbol: 'ghostty_key_encoder_setopt')
external void _ghostty_key_encoder_setopt(
  GhosttyKeyEncoder encoder,
  int option,
  ffi.Pointer<ffi.Void> value,
);

void ghostty_key_encoder_setopt(
  GhosttyKeyEncoder encoder,
  GhosttyKeyEncoderOption option,
  ffi.Pointer<ffi.Void> value,
) => _ghostty_key_encoder_setopt(encoder, option.value, value);

/// Encode a key event into a terminal escape sequence.
///
/// Converts a key event into the appropriate terminal escape sequence based on
/// the encoder's current options. The sequence is written to the provided buffer.
///
/// Not all key events produce output. For example, unmodified modifier keys
/// typically don't generate escape sequences. Check the out_len parameter to
/// determine if any data was written.
///
/// If the output buffer is too small, this function returns GHOSTTY_OUT_OF_MEMORY
/// and out_len will contain the required buffer size. The caller can then
/// allocate a larger buffer and call the function again.
///
/// @param encoder The encoder handle, must not be NULL
/// @param event The key event to encode, must not be NULL
/// @param out_buf Buffer to write the encoded sequence to
/// @param out_buf_size Size of the output buffer in bytes
/// @param out_len Pointer to store the number of bytes written (may be NULL)
/// @return GHOSTTY_SUCCESS on success, GHOSTTY_OUT_OF_MEMORY if buffer too small, or other error code
///
/// ## Example: Calculate required buffer size
///
/// @code{.c}
/// // Query the required size with a NULL buffer (always returns OUT_OF_MEMORY)
/// size_t required = 0;
/// GhosttyResult result = ghostty_key_encoder_encode(encoder, event, NULL, 0, &required);
/// assert(result == GHOSTTY_OUT_OF_MEMORY);
///
/// // Allocate buffer of required size
/// char *buf = malloc(required);
///
/// // Encode with properly sized buffer
/// size_t written = 0;
/// result = ghostty_key_encoder_encode(encoder, event, buf, required, &written);
/// assert(result == GHOSTTY_SUCCESS);
///
/// // Use the encoded sequence...
///
/// free(buf);
/// @endcode
///
/// ## Example: Direct encoding with static buffer
///
/// @code{.c}
/// // Most escape sequences are short, so a static buffer often suffices
/// char buf[128];
/// size_t written = 0;
/// GhosttyResult result = ghostty_key_encoder_encode(encoder, event, buf, sizeof(buf), &written);
///
/// if (result == GHOSTTY_SUCCESS) {
/// // Write the encoded sequence to the terminal
/// write(pty_fd, buf, written);
/// } else if (result == GHOSTTY_OUT_OF_MEMORY) {
/// // Buffer too small, written contains required size
/// char *dynamic_buf = malloc(written);
/// result = ghostty_key_encoder_encode(encoder, event, dynamic_buf, written, &written);
/// assert(result == GHOSTTY_SUCCESS);
/// write(pty_fd, dynamic_buf, written);
/// free(dynamic_buf);
/// }
/// @endcode
///
/// @ingroup key
@ffi.Native<
  ffi.Int Function(
    GhosttyKeyEncoder,
    GhosttyKeyEvent,
    ffi.Pointer<ffi.Char>,
    ffi.Size,
    ffi.Pointer<ffi.Size>,
  )
>(symbol: 'ghostty_key_encoder_encode')
external int _ghostty_key_encoder_encode(
  GhosttyKeyEncoder encoder,
  GhosttyKeyEvent event,
  ffi.Pointer<ffi.Char> out_buf,
  int out_buf_size,
  ffi.Pointer<ffi.Size> out_len,
);

GhosttyResult ghostty_key_encoder_encode(
  GhosttyKeyEncoder encoder,
  GhosttyKeyEvent event,
  ffi.Pointer<ffi.Char> out_buf,
  int out_buf_size,
  ffi.Pointer<ffi.Size> out_len,
) => GhosttyResult.fromValue(
  _ghostty_key_encoder_encode(encoder, event, out_buf, out_buf_size, out_len),
);

/// Check if paste data is safe to paste into the terminal.
///
/// Data is considered unsafe if it contains:
/// - Newlines (`\n`) which can inject commands
/// - The bracketed paste end sequence (`\x1b[201~`) which can be used
/// to exit bracketed paste mode and inject commands
///
/// This check is conservative and considers data unsafe regardless of
/// current terminal state.
///
/// @param data The paste data to check (must not be NULL)
/// @param len The length of the data in bytes
/// @return true if the data is safe to paste, false otherwise
@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>, ffi.Size)>()
external bool ghostty_paste_is_safe(ffi.Pointer<ffi.Char> data, int len);

/// Result codes for libghostty-vt operations.
enum GhosttyResult {
  /// Operation completed successfully
  GHOSTTY_SUCCESS(0),

  /// Operation failed due to failed allocation
  GHOSTTY_OUT_OF_MEMORY(-1),

  /// Operation failed due to invalid value
  GHOSTTY_INVALID_VALUE(-2);

  final int value;
  const GhosttyResult(this.value);

  static GhosttyResult fromValue(int value) => switch (value) {
    0 => GHOSTTY_SUCCESS,
    -1 => GHOSTTY_OUT_OF_MEMORY,
    -2 => GHOSTTY_INVALID_VALUE,
    _ => throw ArgumentError('Unknown value for GhosttyResult: $value'),
  };
}

/// Function table for custom memory allocator operations.
///
/// This vtable defines the interface for a custom memory allocator. All
/// function pointers must be valid and non-NULL.
///
/// @ingroup allocator
///
/// If you're not going to use a custom allocator, you can ignore all of
/// this. All functions that take an allocator pointer allow NULL to use a
/// default allocator.
///
/// The interface is based on the Zig allocator interface. I'll say up front
/// that it is easy to look at this interface and think "wow, this is really
/// overcomplicated". The reason for this complexity is well thought out by
/// the Zig folks, and it enables a diverse set of allocation strategies
/// as shown by the Zig ecosystem. As a consolation, please note that many
/// of the arguments are only needed for advanced use cases and can be
/// safely ignored in simple implementations. For example, if you look at
/// the Zig implementation of the libc allocator in `lib/std/heap.zig`
/// (search for CAllocator), you'll see it is very simple.
///
/// We chose to align with the Zig allocator interface because:
///
/// 1. It is a proven interface that serves a wide variety of use cases
/// in the real world via the Zig ecosystem. It's shown to work.
///
/// 2. Our core implementation itself is Zig, and this lets us very
/// cheaply and easily convert between C and Zig allocators.
///
/// NOTE(mitchellh): In the future, we can have default implementations of
/// resize/remap and allow those to be null.
final class GhosttyAllocatorVtable extends ffi.Struct {
  /// Return a pointer to `len` bytes with specified `alignment`, or return
  /// `NULL` indicating the allocation failed.
  ///
  /// @param ctx The allocator context
  /// @param len Number of bytes to allocate
  /// @param alignment Required alignment for the allocation. Guaranteed to
  /// be a power of two between 1 and 16 inclusive.
  /// @param ret_addr First return address of the allocation call stack (0 if not provided)
  /// @return Pointer to allocated memory, or NULL if allocation failed
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<ffi.Void> ctx,
        ffi.Size len,
        ffi.Uint8 alignment,
        ffi.UintPtr ret_addr,
      )
    >
  >
  alloc;

  /// Attempt to expand or shrink memory in place.
  ///
  /// `memory_len` must equal the length requested from the most recent
  /// successful call to `alloc`, `resize`, or `remap`. `alignment` must
  /// equal the same value that was passed as the `alignment` parameter to
  /// the original `alloc` call.
  ///
  /// `new_len` must be greater than zero.
  ///
  /// @param ctx The allocator context
  /// @param memory Pointer to the memory block to resize
  /// @param memory_len Current size of the memory block
  /// @param alignment Alignment (must match original allocation)
  /// @param new_len New requested size
  /// @param ret_addr First return address of the allocation call stack (0 if not provided)
  /// @return true if resize was successful in-place, false if relocation would be required
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Bool Function(
        ffi.Pointer<ffi.Void> ctx,
        ffi.Pointer<ffi.Void> memory,
        ffi.Size memory_len,
        ffi.Uint8 alignment,
        ffi.Size new_len,
        ffi.UintPtr ret_addr,
      )
    >
  >
  resize;

  /// Attempt to expand or shrink memory, allowing relocation.
  ///
  /// `memory_len` must equal the length requested from the most recent
  /// successful call to `alloc`, `resize`, or `remap`. `alignment` must
  /// equal the same value that was passed as the `alignment` parameter to
  /// the original `alloc` call.
  ///
  /// A non-`NULL` return value indicates the resize was successful. The
  /// allocation may have same address, or may have been relocated. In either
  /// case, the allocation now has size of `new_len`. A `NULL` return value
  /// indicates that the resize would be equivalent to allocating new memory,
  /// copying the bytes from the old memory, and then freeing the old memory.
  /// In such case, it is more efficient for the caller to perform the copy.
  ///
  /// `new_len` must be greater than zero.
  ///
  /// @param ctx The allocator context
  /// @param memory Pointer to the memory block to remap
  /// @param memory_len Current size of the memory block
  /// @param alignment Alignment (must match original allocation)
  /// @param new_len New requested size
  /// @param ret_addr First return address of the allocation call stack (0 if not provided)
  /// @return Pointer to resized memory (may be relocated), or NULL if manual copy is needed
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<ffi.Void> ctx,
        ffi.Pointer<ffi.Void> memory,
        ffi.Size memory_len,
        ffi.Uint8 alignment,
        ffi.Size new_len,
        ffi.UintPtr ret_addr,
      )
    >
  >
  remap;

  /// Free and invalidate a region of memory.
  ///
  /// `memory_len` must equal the length requested from the most recent
  /// successful call to `alloc`, `resize`, or `remap`. `alignment` must
  /// equal the same value that was passed as the `alignment` parameter to
  /// the original `alloc` call.
  ///
  /// @param ctx The allocator context
  /// @param memory Pointer to the memory block to free
  /// @param memory_len Size of the memory block
  /// @param alignment Alignment (must match original allocation)
  /// @param ret_addr First return address of the allocation call stack (0 if not provided)
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Void> ctx,
        ffi.Pointer<ffi.Void> memory,
        ffi.Size memory_len,
        ffi.Uint8 alignment,
        ffi.UintPtr ret_addr,
      )
    >
  >
  free;
}

/// Custom memory allocator.
///
/// For functions that take an allocator pointer, a NULL pointer indicates
/// that the default allocator should be used. The default allocator will
/// be libc malloc/free if we're linking to libc. If libc isn't linked,
/// a custom allocator is used (currently Zig's SMP allocator).
///
/// @ingroup allocator
///
/// Usage example:
/// @code
/// GhosttyAllocator allocator = {
/// .vtable = &my_allocator_vtable,
/// .ctx = my_allocator_state
/// };
/// @endcode
final class GhosttyAllocator extends ffi.Struct {
  /// Opaque context pointer passed to all vtable functions.
  /// This allows the allocator implementation to maintain state
  /// or reference external resources needed for memory management.
  external ffi.Pointer<ffi.Void> ctx;

  /// Pointer to the allocator's vtable containing function pointers
  /// for memory operations (alloc, resize, remap, free).
  external ffi.Pointer<GhosttyAllocatorVtable> vtable;
}

final class GhosttyOscParser$1 extends ffi.Opaque {}

/// Opaque handle to an OSC parser instance.
///
/// This handle represents an OSC (Operating System Command) parser that can
/// be used to parse the contents of OSC sequences.
///
/// @ingroup osc
typedef GhosttyOscParser = ffi.Pointer<GhosttyOscParser$1>;

final class GhosttyOscCommand$1 extends ffi.Opaque {}

/// Opaque handle to a single OSC command.
///
/// This handle represents a parsed OSC (Operating System Command) command.
/// The command can be queried for its type and associated data.
///
/// @ingroup osc
typedef GhosttyOscCommand = ffi.Pointer<GhosttyOscCommand$1>;

/// OSC command types.
///
/// @ingroup osc
enum GhosttyOscCommandType {
  GHOSTTY_OSC_COMMAND_INVALID(0),
  GHOSTTY_OSC_COMMAND_CHANGE_WINDOW_TITLE(1),
  GHOSTTY_OSC_COMMAND_CHANGE_WINDOW_ICON(2),
  GHOSTTY_OSC_COMMAND_SEMANTIC_PROMPT(3),
  GHOSTTY_OSC_COMMAND_CLIPBOARD_CONTENTS(4),
  GHOSTTY_OSC_COMMAND_REPORT_PWD(5),
  GHOSTTY_OSC_COMMAND_MOUSE_SHAPE(6),
  GHOSTTY_OSC_COMMAND_COLOR_OPERATION(7),
  GHOSTTY_OSC_COMMAND_KITTY_COLOR_PROTOCOL(8),
  GHOSTTY_OSC_COMMAND_SHOW_DESKTOP_NOTIFICATION(9),
  GHOSTTY_OSC_COMMAND_HYPERLINK_START(10),
  GHOSTTY_OSC_COMMAND_HYPERLINK_END(11),
  GHOSTTY_OSC_COMMAND_CONEMU_SLEEP(12),
  GHOSTTY_OSC_COMMAND_CONEMU_SHOW_MESSAGE_BOX(13),
  GHOSTTY_OSC_COMMAND_CONEMU_CHANGE_TAB_TITLE(14),
  GHOSTTY_OSC_COMMAND_CONEMU_PROGRESS_REPORT(15),
  GHOSTTY_OSC_COMMAND_CONEMU_WAIT_INPUT(16),
  GHOSTTY_OSC_COMMAND_CONEMU_GUIMACRO(17),
  GHOSTTY_OSC_COMMAND_CONEMU_RUN_PROCESS(18),
  GHOSTTY_OSC_COMMAND_CONEMU_OUTPUT_ENVIRONMENT_VARIABLE(19),
  GHOSTTY_OSC_COMMAND_CONEMU_XTERM_EMULATION(20),
  GHOSTTY_OSC_COMMAND_CONEMU_COMMENT(21),
  GHOSTTY_OSC_COMMAND_KITTY_TEXT_SIZING(22);

  final int value;
  const GhosttyOscCommandType(this.value);

  static GhosttyOscCommandType fromValue(int value) => switch (value) {
    0 => GHOSTTY_OSC_COMMAND_INVALID,
    1 => GHOSTTY_OSC_COMMAND_CHANGE_WINDOW_TITLE,
    2 => GHOSTTY_OSC_COMMAND_CHANGE_WINDOW_ICON,
    3 => GHOSTTY_OSC_COMMAND_SEMANTIC_PROMPT,
    4 => GHOSTTY_OSC_COMMAND_CLIPBOARD_CONTENTS,
    5 => GHOSTTY_OSC_COMMAND_REPORT_PWD,
    6 => GHOSTTY_OSC_COMMAND_MOUSE_SHAPE,
    7 => GHOSTTY_OSC_COMMAND_COLOR_OPERATION,
    8 => GHOSTTY_OSC_COMMAND_KITTY_COLOR_PROTOCOL,
    9 => GHOSTTY_OSC_COMMAND_SHOW_DESKTOP_NOTIFICATION,
    10 => GHOSTTY_OSC_COMMAND_HYPERLINK_START,
    11 => GHOSTTY_OSC_COMMAND_HYPERLINK_END,
    12 => GHOSTTY_OSC_COMMAND_CONEMU_SLEEP,
    13 => GHOSTTY_OSC_COMMAND_CONEMU_SHOW_MESSAGE_BOX,
    14 => GHOSTTY_OSC_COMMAND_CONEMU_CHANGE_TAB_TITLE,
    15 => GHOSTTY_OSC_COMMAND_CONEMU_PROGRESS_REPORT,
    16 => GHOSTTY_OSC_COMMAND_CONEMU_WAIT_INPUT,
    17 => GHOSTTY_OSC_COMMAND_CONEMU_GUIMACRO,
    18 => GHOSTTY_OSC_COMMAND_CONEMU_RUN_PROCESS,
    19 => GHOSTTY_OSC_COMMAND_CONEMU_OUTPUT_ENVIRONMENT_VARIABLE,
    20 => GHOSTTY_OSC_COMMAND_CONEMU_XTERM_EMULATION,
    21 => GHOSTTY_OSC_COMMAND_CONEMU_COMMENT,
    22 => GHOSTTY_OSC_COMMAND_KITTY_TEXT_SIZING,
    _ => throw ArgumentError('Unknown value for GhosttyOscCommandType: $value'),
  };
}

/// OSC command data types.
///
/// These values specify what type of data to extract from an OSC command
/// using `ghostty_osc_command_data`.
///
/// @ingroup osc
enum GhosttyOscCommandData {
  /// Invalid data type. Never results in any data extraction.
  GHOSTTY_OSC_DATA_INVALID(0),

  /// Window title string data.
  ///
  /// Valid for: GHOSTTY_OSC_COMMAND_CHANGE_WINDOW_TITLE
  ///
  /// Output type: const char ** (pointer to null-terminated string)
  ///
  /// Lifetime: Valid until the next call to any ghostty_osc_* function with
  /// the same parser instance. Memory is owned by the parser.
  GHOSTTY_OSC_DATA_CHANGE_WINDOW_TITLE_STR(1);

  final int value;
  const GhosttyOscCommandData(this.value);

  static GhosttyOscCommandData fromValue(int value) => switch (value) {
    0 => GHOSTTY_OSC_DATA_INVALID,
    1 => GHOSTTY_OSC_DATA_CHANGE_WINDOW_TITLE_STR,
    _ => throw ArgumentError('Unknown value for GhosttyOscCommandData: $value'),
  };
}

/// RGB color value.
///
/// @ingroup sgr
final class GhosttyColorRgb extends ffi.Struct {
  /// < Red component (0-255)
  @ffi.Uint8()
  external int r;

  /// < Green component (0-255)
  @ffi.Uint8()
  external int g;

  /// < Blue component (0-255)
  @ffi.Uint8()
  external int b;
}

/// Palette color index (0-255).
///
/// @ingroup sgr
typedef GhosttyColorPaletteIndex = ffi.Uint8;
typedef DartGhosttyColorPaletteIndex = int;

final class GhosttySgrParser$1 extends ffi.Opaque {}

/// Opaque handle to an SGR parser instance.
///
/// This handle represents an SGR (Select Graphic Rendition) parser that can
/// be used to parse SGR sequences and extract individual text attributes.
///
/// @ingroup sgr
typedef GhosttySgrParser = ffi.Pointer<GhosttySgrParser$1>;

/// SGR attribute tags.
///
/// These values identify the type of an SGR attribute in a tagged union.
/// Use the tag to determine which field in the attribute value union to access.
///
/// @ingroup sgr
enum GhosttySgrAttributeTag {
  GHOSTTY_SGR_ATTR_UNSET(0),
  GHOSTTY_SGR_ATTR_UNKNOWN(1),
  GHOSTTY_SGR_ATTR_BOLD(2),
  GHOSTTY_SGR_ATTR_RESET_BOLD(3),
  GHOSTTY_SGR_ATTR_ITALIC(4),
  GHOSTTY_SGR_ATTR_RESET_ITALIC(5),
  GHOSTTY_SGR_ATTR_FAINT(6),
  GHOSTTY_SGR_ATTR_UNDERLINE(7),
  GHOSTTY_SGR_ATTR_RESET_UNDERLINE(8),
  GHOSTTY_SGR_ATTR_UNDERLINE_COLOR(9),
  GHOSTTY_SGR_ATTR_UNDERLINE_COLOR_256(10),
  GHOSTTY_SGR_ATTR_RESET_UNDERLINE_COLOR(11),
  GHOSTTY_SGR_ATTR_OVERLINE(12),
  GHOSTTY_SGR_ATTR_RESET_OVERLINE(13),
  GHOSTTY_SGR_ATTR_BLINK(14),
  GHOSTTY_SGR_ATTR_RESET_BLINK(15),
  GHOSTTY_SGR_ATTR_INVERSE(16),
  GHOSTTY_SGR_ATTR_RESET_INVERSE(17),
  GHOSTTY_SGR_ATTR_INVISIBLE(18),
  GHOSTTY_SGR_ATTR_RESET_INVISIBLE(19),
  GHOSTTY_SGR_ATTR_STRIKETHROUGH(20),
  GHOSTTY_SGR_ATTR_RESET_STRIKETHROUGH(21),
  GHOSTTY_SGR_ATTR_DIRECT_COLOR_FG(22),
  GHOSTTY_SGR_ATTR_DIRECT_COLOR_BG(23),
  GHOSTTY_SGR_ATTR_BG_8(24),
  GHOSTTY_SGR_ATTR_FG_8(25),
  GHOSTTY_SGR_ATTR_RESET_FG(26),
  GHOSTTY_SGR_ATTR_RESET_BG(27),
  GHOSTTY_SGR_ATTR_BRIGHT_BG_8(28),
  GHOSTTY_SGR_ATTR_BRIGHT_FG_8(29),
  GHOSTTY_SGR_ATTR_BG_256(30),
  GHOSTTY_SGR_ATTR_FG_256(31);

  final int value;
  const GhosttySgrAttributeTag(this.value);

  static GhosttySgrAttributeTag fromValue(int value) => switch (value) {
    0 => GHOSTTY_SGR_ATTR_UNSET,
    1 => GHOSTTY_SGR_ATTR_UNKNOWN,
    2 => GHOSTTY_SGR_ATTR_BOLD,
    3 => GHOSTTY_SGR_ATTR_RESET_BOLD,
    4 => GHOSTTY_SGR_ATTR_ITALIC,
    5 => GHOSTTY_SGR_ATTR_RESET_ITALIC,
    6 => GHOSTTY_SGR_ATTR_FAINT,
    7 => GHOSTTY_SGR_ATTR_UNDERLINE,
    8 => GHOSTTY_SGR_ATTR_RESET_UNDERLINE,
    9 => GHOSTTY_SGR_ATTR_UNDERLINE_COLOR,
    10 => GHOSTTY_SGR_ATTR_UNDERLINE_COLOR_256,
    11 => GHOSTTY_SGR_ATTR_RESET_UNDERLINE_COLOR,
    12 => GHOSTTY_SGR_ATTR_OVERLINE,
    13 => GHOSTTY_SGR_ATTR_RESET_OVERLINE,
    14 => GHOSTTY_SGR_ATTR_BLINK,
    15 => GHOSTTY_SGR_ATTR_RESET_BLINK,
    16 => GHOSTTY_SGR_ATTR_INVERSE,
    17 => GHOSTTY_SGR_ATTR_RESET_INVERSE,
    18 => GHOSTTY_SGR_ATTR_INVISIBLE,
    19 => GHOSTTY_SGR_ATTR_RESET_INVISIBLE,
    20 => GHOSTTY_SGR_ATTR_STRIKETHROUGH,
    21 => GHOSTTY_SGR_ATTR_RESET_STRIKETHROUGH,
    22 => GHOSTTY_SGR_ATTR_DIRECT_COLOR_FG,
    23 => GHOSTTY_SGR_ATTR_DIRECT_COLOR_BG,
    24 => GHOSTTY_SGR_ATTR_BG_8,
    25 => GHOSTTY_SGR_ATTR_FG_8,
    26 => GHOSTTY_SGR_ATTR_RESET_FG,
    27 => GHOSTTY_SGR_ATTR_RESET_BG,
    28 => GHOSTTY_SGR_ATTR_BRIGHT_BG_8,
    29 => GHOSTTY_SGR_ATTR_BRIGHT_FG_8,
    30 => GHOSTTY_SGR_ATTR_BG_256,
    31 => GHOSTTY_SGR_ATTR_FG_256,
    _ => throw ArgumentError(
      'Unknown value for GhosttySgrAttributeTag: $value',
    ),
  };
}

/// Underline style types.
///
/// @ingroup sgr
enum GhosttySgrUnderline {
  GHOSTTY_SGR_UNDERLINE_NONE(0),
  GHOSTTY_SGR_UNDERLINE_SINGLE(1),
  GHOSTTY_SGR_UNDERLINE_DOUBLE(2),
  GHOSTTY_SGR_UNDERLINE_CURLY(3),
  GHOSTTY_SGR_UNDERLINE_DOTTED(4),
  GHOSTTY_SGR_UNDERLINE_DASHED(5);

  final int value;
  const GhosttySgrUnderline(this.value);

  static GhosttySgrUnderline fromValue(int value) => switch (value) {
    0 => GHOSTTY_SGR_UNDERLINE_NONE,
    1 => GHOSTTY_SGR_UNDERLINE_SINGLE,
    2 => GHOSTTY_SGR_UNDERLINE_DOUBLE,
    3 => GHOSTTY_SGR_UNDERLINE_CURLY,
    4 => GHOSTTY_SGR_UNDERLINE_DOTTED,
    5 => GHOSTTY_SGR_UNDERLINE_DASHED,
    _ => throw ArgumentError('Unknown value for GhosttySgrUnderline: $value'),
  };
}

/// Unknown SGR attribute data.
///
/// Contains the full parameter list and the partial list where parsing
/// encountered an unknown or invalid sequence.
///
/// @ingroup sgr
final class GhosttySgrUnknown extends ffi.Struct {
  external ffi.Pointer<ffi.Uint16> full_ptr;

  @ffi.Size()
  external int full_len;

  external ffi.Pointer<ffi.Uint16> partial_ptr;

  @ffi.Size()
  external int partial_len;
}

/// SGR attribute value union.
///
/// This union contains all possible attribute values. Use the tag field
/// to determine which union member is active. Attributes without associated
/// data (like bold, italic) don't use the union value.
///
/// @ingroup sgr
final class GhosttySgrAttributeValue extends ffi.Union {
  external GhosttySgrUnknown unknown;

  @ffi.UnsignedInt()
  external int underlineAsInt;

  GhosttySgrUnderline get underline =>
      GhosttySgrUnderline.fromValue(underlineAsInt);

  external GhosttyColorRgb underline_color;

  @GhosttyColorPaletteIndex()
  external int underline_color_256;

  external GhosttyColorRgb direct_color_fg;

  external GhosttyColorRgb direct_color_bg;

  @GhosttyColorPaletteIndex()
  external int bg_8;

  @GhosttyColorPaletteIndex()
  external int fg_8;

  @GhosttyColorPaletteIndex()
  external int bright_bg_8;

  @GhosttyColorPaletteIndex()
  external int bright_fg_8;

  @GhosttyColorPaletteIndex()
  external int bg_256;

  @GhosttyColorPaletteIndex()
  external int fg_256;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint64> _padding;
}

/// SGR attribute (tagged union).
///
/// A complete SGR attribute with both its type tag and associated value.
/// Always check the tag field to determine which value union member is valid.
///
/// Attributes without associated data (e.g., GHOSTTY_SGR_ATTR_BOLD) can be
/// identified by tag alone; the value union is not used for these and
/// the memory in the value field is undefined.
///
/// @ingroup sgr
final class GhosttySgrAttribute extends ffi.Struct {
  @ffi.UnsignedInt()
  external int tagAsInt;

  GhosttySgrAttributeTag get tag => GhosttySgrAttributeTag.fromValue(tagAsInt);

  external GhosttySgrAttributeValue value;
}

final class GhosttyKeyEvent$1 extends ffi.Opaque {}

/// Opaque handle to a key event.
///
/// This handle represents a keyboard input event containing information about
/// the physical key pressed, modifiers, and generated text.
///
/// @ingroup key
typedef GhosttyKeyEvent = ffi.Pointer<GhosttyKeyEvent$1>;

/// Keyboard input event types.
///
/// @ingroup key
enum GhosttyKeyAction {
  /// Key was released
  GHOSTTY_KEY_ACTION_RELEASE(0),

  /// Key was pressed
  GHOSTTY_KEY_ACTION_PRESS(1),

  /// Key is being repeated (held down)
  GHOSTTY_KEY_ACTION_REPEAT(2);

  final int value;
  const GhosttyKeyAction(this.value);

  static GhosttyKeyAction fromValue(int value) => switch (value) {
    0 => GHOSTTY_KEY_ACTION_RELEASE,
    1 => GHOSTTY_KEY_ACTION_PRESS,
    2 => GHOSTTY_KEY_ACTION_REPEAT,
    _ => throw ArgumentError('Unknown value for GhosttyKeyAction: $value'),
  };
}

/// Keyboard modifier keys bitmask.
///
/// A bitmask representing all keyboard modifiers. This tracks which modifier keys
/// are pressed and, where supported by the platform, which side (left or right)
/// of each modifier is active.
///
/// Use the GHOSTTY_MODS_* constants to test and set individual modifiers.
///
/// Modifier side bits are only meaningful when the corresponding modifier bit is set.
/// Not all platforms support distinguishing between left and right modifier
/// keys and Ghostty is built to expect that some platforms may not provide this
/// information.
///
/// @ingroup key
typedef GhosttyMods = ffi.Uint16;
typedef DartGhosttyMods = int;

/// Physical key codes.
///
/// The set of key codes that Ghostty is aware of. These represent physical keys
/// on the keyboard and are layout-independent. For example, the "a" key on a US
/// keyboard is the same as the "ф" key on a Russian keyboard, but both will
/// report the same key_a value.
///
/// Layout-dependent strings are provided separately as UTF-8 text and are produced
/// by the platform. These values are based on the W3C UI Events KeyboardEvent code
/// standard. See: https://www.w3.org/TR/uievents-code
///
/// @ingroup key
enum GhosttyKey {
  GHOSTTY_KEY_UNIDENTIFIED(0),

  /// Writing System Keys (W3C § 3.1.1)
  GHOSTTY_KEY_BACKQUOTE(1),
  GHOSTTY_KEY_BACKSLASH(2),
  GHOSTTY_KEY_BRACKET_LEFT(3),
  GHOSTTY_KEY_BRACKET_RIGHT(4),
  GHOSTTY_KEY_COMMA(5),
  GHOSTTY_KEY_DIGIT_0(6),
  GHOSTTY_KEY_DIGIT_1(7),
  GHOSTTY_KEY_DIGIT_2(8),
  GHOSTTY_KEY_DIGIT_3(9),
  GHOSTTY_KEY_DIGIT_4(10),
  GHOSTTY_KEY_DIGIT_5(11),
  GHOSTTY_KEY_DIGIT_6(12),
  GHOSTTY_KEY_DIGIT_7(13),
  GHOSTTY_KEY_DIGIT_8(14),
  GHOSTTY_KEY_DIGIT_9(15),
  GHOSTTY_KEY_EQUAL(16),
  GHOSTTY_KEY_INTL_BACKSLASH(17),
  GHOSTTY_KEY_INTL_RO(18),
  GHOSTTY_KEY_INTL_YEN(19),
  GHOSTTY_KEY_A(20),
  GHOSTTY_KEY_B(21),
  GHOSTTY_KEY_C(22),
  GHOSTTY_KEY_D(23),
  GHOSTTY_KEY_E(24),
  GHOSTTY_KEY_F(25),
  GHOSTTY_KEY_G(26),
  GHOSTTY_KEY_H(27),
  GHOSTTY_KEY_I(28),
  GHOSTTY_KEY_J(29),
  GHOSTTY_KEY_K(30),
  GHOSTTY_KEY_L(31),
  GHOSTTY_KEY_M(32),
  GHOSTTY_KEY_N(33),
  GHOSTTY_KEY_O(34),
  GHOSTTY_KEY_P(35),
  GHOSTTY_KEY_Q(36),
  GHOSTTY_KEY_R(37),
  GHOSTTY_KEY_S(38),
  GHOSTTY_KEY_T(39),
  GHOSTTY_KEY_U(40),
  GHOSTTY_KEY_V(41),
  GHOSTTY_KEY_W(42),
  GHOSTTY_KEY_X(43),
  GHOSTTY_KEY_Y(44),
  GHOSTTY_KEY_Z(45),
  GHOSTTY_KEY_MINUS(46),
  GHOSTTY_KEY_PERIOD(47),
  GHOSTTY_KEY_QUOTE(48),
  GHOSTTY_KEY_SEMICOLON(49),
  GHOSTTY_KEY_SLASH(50),

  /// Functional Keys (W3C § 3.1.2)
  GHOSTTY_KEY_ALT_LEFT(51),
  GHOSTTY_KEY_ALT_RIGHT(52),
  GHOSTTY_KEY_BACKSPACE(53),
  GHOSTTY_KEY_CAPS_LOCK(54),
  GHOSTTY_KEY_CONTEXT_MENU(55),
  GHOSTTY_KEY_CONTROL_LEFT(56),
  GHOSTTY_KEY_CONTROL_RIGHT(57),
  GHOSTTY_KEY_ENTER(58),
  GHOSTTY_KEY_META_LEFT(59),
  GHOSTTY_KEY_META_RIGHT(60),
  GHOSTTY_KEY_SHIFT_LEFT(61),
  GHOSTTY_KEY_SHIFT_RIGHT(62),
  GHOSTTY_KEY_SPACE(63),
  GHOSTTY_KEY_TAB(64),
  GHOSTTY_KEY_CONVERT(65),
  GHOSTTY_KEY_KANA_MODE(66),
  GHOSTTY_KEY_NON_CONVERT(67),

  /// Control Pad Section (W3C § 3.2)
  GHOSTTY_KEY_DELETE(68),
  GHOSTTY_KEY_END(69),
  GHOSTTY_KEY_HELP(70),
  GHOSTTY_KEY_HOME(71),
  GHOSTTY_KEY_INSERT(72),
  GHOSTTY_KEY_PAGE_DOWN(73),
  GHOSTTY_KEY_PAGE_UP(74),

  /// Arrow Pad Section (W3C § 3.3)
  GHOSTTY_KEY_ARROW_DOWN(75),
  GHOSTTY_KEY_ARROW_LEFT(76),
  GHOSTTY_KEY_ARROW_RIGHT(77),
  GHOSTTY_KEY_ARROW_UP(78),

  /// Numpad Section (W3C § 3.4)
  GHOSTTY_KEY_NUM_LOCK(79),
  GHOSTTY_KEY_NUMPAD_0(80),
  GHOSTTY_KEY_NUMPAD_1(81),
  GHOSTTY_KEY_NUMPAD_2(82),
  GHOSTTY_KEY_NUMPAD_3(83),
  GHOSTTY_KEY_NUMPAD_4(84),
  GHOSTTY_KEY_NUMPAD_5(85),
  GHOSTTY_KEY_NUMPAD_6(86),
  GHOSTTY_KEY_NUMPAD_7(87),
  GHOSTTY_KEY_NUMPAD_8(88),
  GHOSTTY_KEY_NUMPAD_9(89),
  GHOSTTY_KEY_NUMPAD_ADD(90),
  GHOSTTY_KEY_NUMPAD_BACKSPACE(91),
  GHOSTTY_KEY_NUMPAD_CLEAR(92),
  GHOSTTY_KEY_NUMPAD_CLEAR_ENTRY(93),
  GHOSTTY_KEY_NUMPAD_COMMA(94),
  GHOSTTY_KEY_NUMPAD_DECIMAL(95),
  GHOSTTY_KEY_NUMPAD_DIVIDE(96),
  GHOSTTY_KEY_NUMPAD_ENTER(97),
  GHOSTTY_KEY_NUMPAD_EQUAL(98),
  GHOSTTY_KEY_NUMPAD_MEMORY_ADD(99),
  GHOSTTY_KEY_NUMPAD_MEMORY_CLEAR(100),
  GHOSTTY_KEY_NUMPAD_MEMORY_RECALL(101),
  GHOSTTY_KEY_NUMPAD_MEMORY_STORE(102),
  GHOSTTY_KEY_NUMPAD_MEMORY_SUBTRACT(103),
  GHOSTTY_KEY_NUMPAD_MULTIPLY(104),
  GHOSTTY_KEY_NUMPAD_PAREN_LEFT(105),
  GHOSTTY_KEY_NUMPAD_PAREN_RIGHT(106),
  GHOSTTY_KEY_NUMPAD_SUBTRACT(107),
  GHOSTTY_KEY_NUMPAD_SEPARATOR(108),
  GHOSTTY_KEY_NUMPAD_UP(109),
  GHOSTTY_KEY_NUMPAD_DOWN(110),
  GHOSTTY_KEY_NUMPAD_RIGHT(111),
  GHOSTTY_KEY_NUMPAD_LEFT(112),
  GHOSTTY_KEY_NUMPAD_BEGIN(113),
  GHOSTTY_KEY_NUMPAD_HOME(114),
  GHOSTTY_KEY_NUMPAD_END(115),
  GHOSTTY_KEY_NUMPAD_INSERT(116),
  GHOSTTY_KEY_NUMPAD_DELETE(117),
  GHOSTTY_KEY_NUMPAD_PAGE_UP(118),
  GHOSTTY_KEY_NUMPAD_PAGE_DOWN(119),

  /// Function Section (W3C § 3.5)
  GHOSTTY_KEY_ESCAPE(120),
  GHOSTTY_KEY_F1(121),
  GHOSTTY_KEY_F2(122),
  GHOSTTY_KEY_F3(123),
  GHOSTTY_KEY_F4(124),
  GHOSTTY_KEY_F5(125),
  GHOSTTY_KEY_F6(126),
  GHOSTTY_KEY_F7(127),
  GHOSTTY_KEY_F8(128),
  GHOSTTY_KEY_F9(129),
  GHOSTTY_KEY_F10(130),
  GHOSTTY_KEY_F11(131),
  GHOSTTY_KEY_F12(132),
  GHOSTTY_KEY_F13(133),
  GHOSTTY_KEY_F14(134),
  GHOSTTY_KEY_F15(135),
  GHOSTTY_KEY_F16(136),
  GHOSTTY_KEY_F17(137),
  GHOSTTY_KEY_F18(138),
  GHOSTTY_KEY_F19(139),
  GHOSTTY_KEY_F20(140),
  GHOSTTY_KEY_F21(141),
  GHOSTTY_KEY_F22(142),
  GHOSTTY_KEY_F23(143),
  GHOSTTY_KEY_F24(144),
  GHOSTTY_KEY_F25(145),
  GHOSTTY_KEY_FN(146),
  GHOSTTY_KEY_FN_LOCK(147),
  GHOSTTY_KEY_PRINT_SCREEN(148),
  GHOSTTY_KEY_SCROLL_LOCK(149),
  GHOSTTY_KEY_PAUSE(150),

  /// Media Keys (W3C § 3.6)
  GHOSTTY_KEY_BROWSER_BACK(151),
  GHOSTTY_KEY_BROWSER_FAVORITES(152),
  GHOSTTY_KEY_BROWSER_FORWARD(153),
  GHOSTTY_KEY_BROWSER_HOME(154),
  GHOSTTY_KEY_BROWSER_REFRESH(155),
  GHOSTTY_KEY_BROWSER_SEARCH(156),
  GHOSTTY_KEY_BROWSER_STOP(157),
  GHOSTTY_KEY_EJECT(158),
  GHOSTTY_KEY_LAUNCH_APP_1(159),
  GHOSTTY_KEY_LAUNCH_APP_2(160),
  GHOSTTY_KEY_LAUNCH_MAIL(161),
  GHOSTTY_KEY_MEDIA_PLAY_PAUSE(162),
  GHOSTTY_KEY_MEDIA_SELECT(163),
  GHOSTTY_KEY_MEDIA_STOP(164),
  GHOSTTY_KEY_MEDIA_TRACK_NEXT(165),
  GHOSTTY_KEY_MEDIA_TRACK_PREVIOUS(166),
  GHOSTTY_KEY_POWER(167),
  GHOSTTY_KEY_SLEEP(168),
  GHOSTTY_KEY_AUDIO_VOLUME_DOWN(169),
  GHOSTTY_KEY_AUDIO_VOLUME_MUTE(170),
  GHOSTTY_KEY_AUDIO_VOLUME_UP(171),
  GHOSTTY_KEY_WAKE_UP(172),

  /// Legacy, Non-standard, and Special Keys (W3C § 3.7)
  GHOSTTY_KEY_COPY(173),
  GHOSTTY_KEY_CUT(174),
  GHOSTTY_KEY_PASTE(175);

  final int value;
  const GhosttyKey(this.value);

  static GhosttyKey fromValue(int value) => switch (value) {
    0 => GHOSTTY_KEY_UNIDENTIFIED,
    1 => GHOSTTY_KEY_BACKQUOTE,
    2 => GHOSTTY_KEY_BACKSLASH,
    3 => GHOSTTY_KEY_BRACKET_LEFT,
    4 => GHOSTTY_KEY_BRACKET_RIGHT,
    5 => GHOSTTY_KEY_COMMA,
    6 => GHOSTTY_KEY_DIGIT_0,
    7 => GHOSTTY_KEY_DIGIT_1,
    8 => GHOSTTY_KEY_DIGIT_2,
    9 => GHOSTTY_KEY_DIGIT_3,
    10 => GHOSTTY_KEY_DIGIT_4,
    11 => GHOSTTY_KEY_DIGIT_5,
    12 => GHOSTTY_KEY_DIGIT_6,
    13 => GHOSTTY_KEY_DIGIT_7,
    14 => GHOSTTY_KEY_DIGIT_8,
    15 => GHOSTTY_KEY_DIGIT_9,
    16 => GHOSTTY_KEY_EQUAL,
    17 => GHOSTTY_KEY_INTL_BACKSLASH,
    18 => GHOSTTY_KEY_INTL_RO,
    19 => GHOSTTY_KEY_INTL_YEN,
    20 => GHOSTTY_KEY_A,
    21 => GHOSTTY_KEY_B,
    22 => GHOSTTY_KEY_C,
    23 => GHOSTTY_KEY_D,
    24 => GHOSTTY_KEY_E,
    25 => GHOSTTY_KEY_F,
    26 => GHOSTTY_KEY_G,
    27 => GHOSTTY_KEY_H,
    28 => GHOSTTY_KEY_I,
    29 => GHOSTTY_KEY_J,
    30 => GHOSTTY_KEY_K,
    31 => GHOSTTY_KEY_L,
    32 => GHOSTTY_KEY_M,
    33 => GHOSTTY_KEY_N,
    34 => GHOSTTY_KEY_O,
    35 => GHOSTTY_KEY_P,
    36 => GHOSTTY_KEY_Q,
    37 => GHOSTTY_KEY_R,
    38 => GHOSTTY_KEY_S,
    39 => GHOSTTY_KEY_T,
    40 => GHOSTTY_KEY_U,
    41 => GHOSTTY_KEY_V,
    42 => GHOSTTY_KEY_W,
    43 => GHOSTTY_KEY_X,
    44 => GHOSTTY_KEY_Y,
    45 => GHOSTTY_KEY_Z,
    46 => GHOSTTY_KEY_MINUS,
    47 => GHOSTTY_KEY_PERIOD,
    48 => GHOSTTY_KEY_QUOTE,
    49 => GHOSTTY_KEY_SEMICOLON,
    50 => GHOSTTY_KEY_SLASH,
    51 => GHOSTTY_KEY_ALT_LEFT,
    52 => GHOSTTY_KEY_ALT_RIGHT,
    53 => GHOSTTY_KEY_BACKSPACE,
    54 => GHOSTTY_KEY_CAPS_LOCK,
    55 => GHOSTTY_KEY_CONTEXT_MENU,
    56 => GHOSTTY_KEY_CONTROL_LEFT,
    57 => GHOSTTY_KEY_CONTROL_RIGHT,
    58 => GHOSTTY_KEY_ENTER,
    59 => GHOSTTY_KEY_META_LEFT,
    60 => GHOSTTY_KEY_META_RIGHT,
    61 => GHOSTTY_KEY_SHIFT_LEFT,
    62 => GHOSTTY_KEY_SHIFT_RIGHT,
    63 => GHOSTTY_KEY_SPACE,
    64 => GHOSTTY_KEY_TAB,
    65 => GHOSTTY_KEY_CONVERT,
    66 => GHOSTTY_KEY_KANA_MODE,
    67 => GHOSTTY_KEY_NON_CONVERT,
    68 => GHOSTTY_KEY_DELETE,
    69 => GHOSTTY_KEY_END,
    70 => GHOSTTY_KEY_HELP,
    71 => GHOSTTY_KEY_HOME,
    72 => GHOSTTY_KEY_INSERT,
    73 => GHOSTTY_KEY_PAGE_DOWN,
    74 => GHOSTTY_KEY_PAGE_UP,
    75 => GHOSTTY_KEY_ARROW_DOWN,
    76 => GHOSTTY_KEY_ARROW_LEFT,
    77 => GHOSTTY_KEY_ARROW_RIGHT,
    78 => GHOSTTY_KEY_ARROW_UP,
    79 => GHOSTTY_KEY_NUM_LOCK,
    80 => GHOSTTY_KEY_NUMPAD_0,
    81 => GHOSTTY_KEY_NUMPAD_1,
    82 => GHOSTTY_KEY_NUMPAD_2,
    83 => GHOSTTY_KEY_NUMPAD_3,
    84 => GHOSTTY_KEY_NUMPAD_4,
    85 => GHOSTTY_KEY_NUMPAD_5,
    86 => GHOSTTY_KEY_NUMPAD_6,
    87 => GHOSTTY_KEY_NUMPAD_7,
    88 => GHOSTTY_KEY_NUMPAD_8,
    89 => GHOSTTY_KEY_NUMPAD_9,
    90 => GHOSTTY_KEY_NUMPAD_ADD,
    91 => GHOSTTY_KEY_NUMPAD_BACKSPACE,
    92 => GHOSTTY_KEY_NUMPAD_CLEAR,
    93 => GHOSTTY_KEY_NUMPAD_CLEAR_ENTRY,
    94 => GHOSTTY_KEY_NUMPAD_COMMA,
    95 => GHOSTTY_KEY_NUMPAD_DECIMAL,
    96 => GHOSTTY_KEY_NUMPAD_DIVIDE,
    97 => GHOSTTY_KEY_NUMPAD_ENTER,
    98 => GHOSTTY_KEY_NUMPAD_EQUAL,
    99 => GHOSTTY_KEY_NUMPAD_MEMORY_ADD,
    100 => GHOSTTY_KEY_NUMPAD_MEMORY_CLEAR,
    101 => GHOSTTY_KEY_NUMPAD_MEMORY_RECALL,
    102 => GHOSTTY_KEY_NUMPAD_MEMORY_STORE,
    103 => GHOSTTY_KEY_NUMPAD_MEMORY_SUBTRACT,
    104 => GHOSTTY_KEY_NUMPAD_MULTIPLY,
    105 => GHOSTTY_KEY_NUMPAD_PAREN_LEFT,
    106 => GHOSTTY_KEY_NUMPAD_PAREN_RIGHT,
    107 => GHOSTTY_KEY_NUMPAD_SUBTRACT,
    108 => GHOSTTY_KEY_NUMPAD_SEPARATOR,
    109 => GHOSTTY_KEY_NUMPAD_UP,
    110 => GHOSTTY_KEY_NUMPAD_DOWN,
    111 => GHOSTTY_KEY_NUMPAD_RIGHT,
    112 => GHOSTTY_KEY_NUMPAD_LEFT,
    113 => GHOSTTY_KEY_NUMPAD_BEGIN,
    114 => GHOSTTY_KEY_NUMPAD_HOME,
    115 => GHOSTTY_KEY_NUMPAD_END,
    116 => GHOSTTY_KEY_NUMPAD_INSERT,
    117 => GHOSTTY_KEY_NUMPAD_DELETE,
    118 => GHOSTTY_KEY_NUMPAD_PAGE_UP,
    119 => GHOSTTY_KEY_NUMPAD_PAGE_DOWN,
    120 => GHOSTTY_KEY_ESCAPE,
    121 => GHOSTTY_KEY_F1,
    122 => GHOSTTY_KEY_F2,
    123 => GHOSTTY_KEY_F3,
    124 => GHOSTTY_KEY_F4,
    125 => GHOSTTY_KEY_F5,
    126 => GHOSTTY_KEY_F6,
    127 => GHOSTTY_KEY_F7,
    128 => GHOSTTY_KEY_F8,
    129 => GHOSTTY_KEY_F9,
    130 => GHOSTTY_KEY_F10,
    131 => GHOSTTY_KEY_F11,
    132 => GHOSTTY_KEY_F12,
    133 => GHOSTTY_KEY_F13,
    134 => GHOSTTY_KEY_F14,
    135 => GHOSTTY_KEY_F15,
    136 => GHOSTTY_KEY_F16,
    137 => GHOSTTY_KEY_F17,
    138 => GHOSTTY_KEY_F18,
    139 => GHOSTTY_KEY_F19,
    140 => GHOSTTY_KEY_F20,
    141 => GHOSTTY_KEY_F21,
    142 => GHOSTTY_KEY_F22,
    143 => GHOSTTY_KEY_F23,
    144 => GHOSTTY_KEY_F24,
    145 => GHOSTTY_KEY_F25,
    146 => GHOSTTY_KEY_FN,
    147 => GHOSTTY_KEY_FN_LOCK,
    148 => GHOSTTY_KEY_PRINT_SCREEN,
    149 => GHOSTTY_KEY_SCROLL_LOCK,
    150 => GHOSTTY_KEY_PAUSE,
    151 => GHOSTTY_KEY_BROWSER_BACK,
    152 => GHOSTTY_KEY_BROWSER_FAVORITES,
    153 => GHOSTTY_KEY_BROWSER_FORWARD,
    154 => GHOSTTY_KEY_BROWSER_HOME,
    155 => GHOSTTY_KEY_BROWSER_REFRESH,
    156 => GHOSTTY_KEY_BROWSER_SEARCH,
    157 => GHOSTTY_KEY_BROWSER_STOP,
    158 => GHOSTTY_KEY_EJECT,
    159 => GHOSTTY_KEY_LAUNCH_APP_1,
    160 => GHOSTTY_KEY_LAUNCH_APP_2,
    161 => GHOSTTY_KEY_LAUNCH_MAIL,
    162 => GHOSTTY_KEY_MEDIA_PLAY_PAUSE,
    163 => GHOSTTY_KEY_MEDIA_SELECT,
    164 => GHOSTTY_KEY_MEDIA_STOP,
    165 => GHOSTTY_KEY_MEDIA_TRACK_NEXT,
    166 => GHOSTTY_KEY_MEDIA_TRACK_PREVIOUS,
    167 => GHOSTTY_KEY_POWER,
    168 => GHOSTTY_KEY_SLEEP,
    169 => GHOSTTY_KEY_AUDIO_VOLUME_DOWN,
    170 => GHOSTTY_KEY_AUDIO_VOLUME_MUTE,
    171 => GHOSTTY_KEY_AUDIO_VOLUME_UP,
    172 => GHOSTTY_KEY_WAKE_UP,
    173 => GHOSTTY_KEY_COPY,
    174 => GHOSTTY_KEY_CUT,
    175 => GHOSTTY_KEY_PASTE,
    _ => throw ArgumentError('Unknown value for GhosttyKey: $value'),
  };
}

final class GhosttyKeyEncoder$1 extends ffi.Opaque {}

/// Opaque handle to a key encoder instance.
///
/// This handle represents a key encoder that converts key events into terminal
/// escape sequences.
///
/// @ingroup key
typedef GhosttyKeyEncoder = ffi.Pointer<GhosttyKeyEncoder$1>;

/// Kitty keyboard protocol flags.
///
/// Bitflags representing the various modes of the Kitty keyboard protocol.
/// These can be combined using bitwise OR operations. Valid values all
/// start with `GHOSTTY_KITTY_KEY_`.
///
/// @ingroup key
typedef GhosttyKittyKeyFlags = ffi.Uint8;
typedef DartGhosttyKittyKeyFlags = int;

/// macOS option key behavior.
///
/// Determines whether the "option" key on macOS is treated as "alt" or not.
/// See the Ghostty `macos-option-as-alt` configuration option for more details.
///
/// @ingroup key
enum GhosttyOptionAsAlt {
  /// Option key is not treated as alt
  GHOSTTY_OPTION_AS_ALT_FALSE(0),

  /// Option key is treated as alt
  GHOSTTY_OPTION_AS_ALT_TRUE(1),

  /// Only left option key is treated as alt
  GHOSTTY_OPTION_AS_ALT_LEFT(2),

  /// Only right option key is treated as alt
  GHOSTTY_OPTION_AS_ALT_RIGHT(3);

  final int value;
  const GhosttyOptionAsAlt(this.value);

  static GhosttyOptionAsAlt fromValue(int value) => switch (value) {
    0 => GHOSTTY_OPTION_AS_ALT_FALSE,
    1 => GHOSTTY_OPTION_AS_ALT_TRUE,
    2 => GHOSTTY_OPTION_AS_ALT_LEFT,
    3 => GHOSTTY_OPTION_AS_ALT_RIGHT,
    _ => throw ArgumentError('Unknown value for GhosttyOptionAsAlt: $value'),
  };
}

/// Key encoder option identifiers.
///
/// These values are used with ghostty_key_encoder_setopt() to configure
/// the behavior of the key encoder.
///
/// @ingroup key
enum GhosttyKeyEncoderOption {
  /// Terminal DEC mode 1: cursor key application mode (value: bool)
  GHOSTTY_KEY_ENCODER_OPT_CURSOR_KEY_APPLICATION(0),

  /// Terminal DEC mode 66: keypad key application mode (value: bool)
  GHOSTTY_KEY_ENCODER_OPT_KEYPAD_KEY_APPLICATION(1),

  /// Terminal DEC mode 1035: ignore keypad with numlock (value: bool)
  GHOSTTY_KEY_ENCODER_OPT_IGNORE_KEYPAD_WITH_NUMLOCK(2),

  /// Terminal DEC mode 1036: alt sends escape prefix (value: bool)
  GHOSTTY_KEY_ENCODER_OPT_ALT_ESC_PREFIX(3),

  /// xterm modifyOtherKeys mode 2 (value: bool)
  GHOSTTY_KEY_ENCODER_OPT_MODIFY_OTHER_KEYS_STATE_2(4),

  /// Kitty keyboard protocol flags (value: GhosttyKittyKeyFlags bitmask)
  GHOSTTY_KEY_ENCODER_OPT_KITTY_FLAGS(5),

  /// macOS option-as-alt setting (value: GhosttyOptionAsAlt)
  GHOSTTY_KEY_ENCODER_OPT_MACOS_OPTION_AS_ALT(6);

  final int value;
  const GhosttyKeyEncoderOption(this.value);

  static GhosttyKeyEncoderOption fromValue(int value) => switch (value) {
    0 => GHOSTTY_KEY_ENCODER_OPT_CURSOR_KEY_APPLICATION,
    1 => GHOSTTY_KEY_ENCODER_OPT_KEYPAD_KEY_APPLICATION,
    2 => GHOSTTY_KEY_ENCODER_OPT_IGNORE_KEYPAD_WITH_NUMLOCK,
    3 => GHOSTTY_KEY_ENCODER_OPT_ALT_ESC_PREFIX,
    4 => GHOSTTY_KEY_ENCODER_OPT_MODIFY_OTHER_KEYS_STATE_2,
    5 => GHOSTTY_KEY_ENCODER_OPT_KITTY_FLAGS,
    6 => GHOSTTY_KEY_ENCODER_OPT_MACOS_OPTION_AS_ALT,
    _ => throw ArgumentError(
      'Unknown value for GhosttyKeyEncoderOption: $value',
    ),
  };
}

const int GHOSTTY_COLOR_NAMED_BLACK = 0;

const int GHOSTTY_COLOR_NAMED_RED = 1;

const int GHOSTTY_COLOR_NAMED_GREEN = 2;

const int GHOSTTY_COLOR_NAMED_YELLOW = 3;

const int GHOSTTY_COLOR_NAMED_BLUE = 4;

const int GHOSTTY_COLOR_NAMED_MAGENTA = 5;

const int GHOSTTY_COLOR_NAMED_CYAN = 6;

const int GHOSTTY_COLOR_NAMED_WHITE = 7;

const int GHOSTTY_COLOR_NAMED_BRIGHT_BLACK = 8;

const int GHOSTTY_COLOR_NAMED_BRIGHT_RED = 9;

const int GHOSTTY_COLOR_NAMED_BRIGHT_GREEN = 10;

const int GHOSTTY_COLOR_NAMED_BRIGHT_YELLOW = 11;

const int GHOSTTY_COLOR_NAMED_BRIGHT_BLUE = 12;

const int GHOSTTY_COLOR_NAMED_BRIGHT_MAGENTA = 13;

const int GHOSTTY_COLOR_NAMED_BRIGHT_CYAN = 14;

const int GHOSTTY_COLOR_NAMED_BRIGHT_WHITE = 15;

const int GHOSTTY_MODS_SHIFT = 1;

const int GHOSTTY_MODS_CTRL = 2;

const int GHOSTTY_MODS_ALT = 4;

const int GHOSTTY_MODS_SUPER = 8;

const int GHOSTTY_MODS_CAPS_LOCK = 16;

const int GHOSTTY_MODS_NUM_LOCK = 32;

const int GHOSTTY_MODS_SHIFT_SIDE = 64;

const int GHOSTTY_MODS_CTRL_SIDE = 128;

const int GHOSTTY_MODS_ALT_SIDE = 256;

const int GHOSTTY_MODS_SUPER_SIDE = 512;

const int GHOSTTY_KITTY_KEY_DISABLED = 0;

const int GHOSTTY_KITTY_KEY_DISAMBIGUATE = 1;

const int GHOSTTY_KITTY_KEY_REPORT_EVENTS = 2;

const int GHOSTTY_KITTY_KEY_REPORT_ALTERNATES = 4;

const int GHOSTTY_KITTY_KEY_REPORT_ALL = 8;

const int GHOSTTY_KITTY_KEY_REPORT_ASSOCIATED = 16;

const int GHOSTTY_KITTY_KEY_ALL = 31;
