// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// Open a new PTY with the given dimensions.
///
/// On success, writes the opaque handle to `*out` and returns `Ok`.
@ffi.Native<
  ffi.UnsignedInt Function(
    ffi.Uint16,
    ffi.Uint16,
    ffi.Pointer<ffi.Pointer<PortablePty>>,
  )
>(symbol: 'portable_pty_open')
external int _portable_pty_open(
  int rows,
  int cols,
  ffi.Pointer<ffi.Pointer<PortablePty>> out,
);

PortablePtyResult portable_pty_open(
  int rows,
  int cols,
  ffi.Pointer<ffi.Pointer<PortablePty>> out,
) => PortablePtyResult.fromValue(_portable_pty_open(rows, cols, out));

/// Spawn a child process attached to the PTY.
///
/// - `cmd`: null-terminated executable path.
/// - `argv`: null-terminated array of null-terminated argument strings,
/// or NULL to use `cmd` as the sole argument.
/// - `envp`: null-terminated array of `"KEY=VALUE"` strings, or NULL to
/// inherit the current environment.
@ffi.Native<
  ffi.UnsignedInt Function(
    ffi.Pointer<PortablePty>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Pointer<ffi.Char>>,
    ffi.Pointer<ffi.Pointer<ffi.Char>>,
  )
>(symbol: 'portable_pty_spawn')
external int _portable_pty_spawn(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Char> cmd,
  ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ffi.Pointer<ffi.Pointer<ffi.Char>> envp,
);

PortablePtyResult portable_pty_spawn(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Char> cmd,
  ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ffi.Pointer<ffi.Pointer<ffi.Char>> envp,
) => PortablePtyResult.fromValue(_portable_pty_spawn(handle, cmd, argv, envp));

/// Read bytes from the PTY master side (child's stdout).
///
/// Returns number of bytes read, or -1 on error/EOF.
@ffi.Native<
  ffi.Int64 Function(
    ffi.Pointer<PortablePty>,
    ffi.Pointer<ffi.Uint8>,
    ffi.UintPtr,
  )
>()
external int portable_pty_read(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Uint8> buf,
  int len,
);

/// Write bytes to the PTY master side (child's stdin).
///
/// Returns number of bytes written, or -1 on error.
@ffi.Native<
  ffi.Int64 Function(
    ffi.Pointer<PortablePty>,
    ffi.Pointer<ffi.Uint8>,
    ffi.UintPtr,
  )
>()
external int portable_pty_write(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Uint8> buf,
  int len,
);

/// Resize the PTY.
@ffi.Native<
  ffi.UnsignedInt Function(ffi.Pointer<PortablePty>, ffi.Uint16, ffi.Uint16)
>(symbol: 'portable_pty_resize')
external int _portable_pty_resize(
  ffi.Pointer<PortablePty> handle,
  int rows,
  int cols,
);

PortablePtyResult portable_pty_resize(
  ffi.Pointer<PortablePty> handle,
  int rows,
  int cols,
) => PortablePtyResult.fromValue(_portable_pty_resize(handle, rows, cols));

/// Get the PTY master side file descriptor.
@ffi.Native<ffi.Int Function(ffi.Pointer<PortablePty>)>()
external int portable_pty_master_fd(ffi.Pointer<PortablePty> handle);

/// Get the current PTY size as tracked by the kernel.
@ffi.Native<
  ffi.UnsignedInt Function(
    ffi.Pointer<PortablePty>,
    ffi.Pointer<ffi.Uint16>,
    ffi.Pointer<ffi.Uint16>,
    ffi.Pointer<ffi.Uint16>,
    ffi.Pointer<ffi.Uint16>,
  )
>(symbol: 'portable_pty_get_size')
external int _portable_pty_get_size(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Uint16> out_rows,
  ffi.Pointer<ffi.Uint16> out_cols,
  ffi.Pointer<ffi.Uint16> out_pixel_width,
  ffi.Pointer<ffi.Uint16> out_pixel_height,
);

PortablePtyResult portable_pty_get_size(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Uint16> out_rows,
  ffi.Pointer<ffi.Uint16> out_cols,
  ffi.Pointer<ffi.Uint16> out_pixel_width,
  ffi.Pointer<ffi.Uint16> out_pixel_height,
) => PortablePtyResult.fromValue(
  _portable_pty_get_size(
    handle,
    out_rows,
    out_cols,
    out_pixel_width,
    out_pixel_height,
  ),
);

/// Get the child PID, or -1 if no child has been spawned.
@ffi.Native<ffi.Int32 Function(ffi.Pointer<PortablePty>)>()
external int portable_pty_child_pid(ffi.Pointer<PortablePty> handle);

/// Non-blocking wait for child exit.
///
/// Returns `Ok` if child exited (writes exit code to `*out_status`).
/// Returns `ErrWait` if child is still running.
@ffi.Native<
  ffi.UnsignedInt Function(ffi.Pointer<PortablePty>, ffi.Pointer<ffi.Int>)
>(symbol: 'portable_pty_wait')
external int _portable_pty_wait(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Int> out_status,
);

PortablePtyResult portable_pty_wait(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Int> out_status,
) => PortablePtyResult.fromValue(_portable_pty_wait(handle, out_status));

/// Block until the child exits and return its exit code.
@ffi.Native<
  ffi.UnsignedInt Function(ffi.Pointer<PortablePty>, ffi.Pointer<ffi.Int>)
>(symbol: 'portable_pty_wait_blocking')
external int _portable_pty_wait_blocking(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Int> out_status,
);

PortablePtyResult portable_pty_wait_blocking(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Int> out_status,
) => PortablePtyResult.fromValue(
  _portable_pty_wait_blocking(handle, out_status),
);

/// Kill the child process.
///
/// On POSIX, `signal` is the signal number (e.g. 15 for SIGTERM).
/// On Windows, `signal` is ignored â€” the process is terminated.
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<PortablePty>, ffi.Int)>(
  symbol: 'portable_pty_kill',
)
external int _portable_pty_kill(ffi.Pointer<PortablePty> handle, int _signal);

PortablePtyResult portable_pty_kill(
  ffi.Pointer<PortablePty> handle,
  int _signal,
) => PortablePtyResult.fromValue(_portable_pty_kill(handle, _signal));

/// Return the master process group ID (POSIX) or -1 when unsupported.
@ffi.Native<ffi.Int Function(ffi.Pointer<PortablePty>)>()
external int portable_pty_process_group_leader(ffi.Pointer<PortablePty> handle);

/// Get the current terminal mode flags.
///
/// - `out_canonical`: true when canonical mode is enabled.
/// - `out_echo`: true when echo mode is enabled.
@ffi.Native<
  ffi.UnsignedInt Function(
    ffi.Pointer<PortablePty>,
    ffi.Pointer<ffi.Bool>,
    ffi.Pointer<ffi.Bool>,
  )
>(symbol: 'portable_pty_get_mode')
external int _portable_pty_get_mode(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Bool> out_canonical,
  ffi.Pointer<ffi.Bool> out_echo,
);

PortablePtyResult portable_pty_get_mode(
  ffi.Pointer<PortablePty> handle,
  ffi.Pointer<ffi.Bool> out_canonical,
  ffi.Pointer<ffi.Bool> out_echo,
) => PortablePtyResult.fromValue(
  _portable_pty_get_mode(handle, out_canonical, out_echo),
);

/// Close the PTY and free all resources.
///
/// Kills the child process if still running. Safe to call with NULL.
@ffi.Native<ffi.Void Function(ffi.Pointer<PortablePty>)>()
external void portable_pty_close(ffi.Pointer<PortablePty> handle);

enum PortablePtyResult {
  Ok(0),
  ErrOpen(1),
  ErrSpawn(2),
  ErrResize(3),
  ErrRead(4),
  ErrWrite(5),
  ErrNull(6),
  ErrWait(7),
  ErrKill(8),
  ErrMode(9),
  ErrSize(10),
  ErrWaitBlocking(11),
  ErrProcessGroup(12);

  final int value;
  const PortablePtyResult(this.value);

  static PortablePtyResult fromValue(int value) => switch (value) {
    0 => Ok,
    1 => ErrOpen,
    2 => ErrSpawn,
    3 => ErrResize,
    4 => ErrRead,
    5 => ErrWrite,
    6 => ErrNull,
    7 => ErrWait,
    8 => ErrKill,
    9 => ErrMode,
    10 => ErrSize,
    11 => ErrWaitBlocking,
    12 => ErrProcessGroup,
    _ => throw ArgumentError('Unknown value for PortablePtyResult: $value'),
  };
}

final class PortablePty extends ffi.Opaque {}
